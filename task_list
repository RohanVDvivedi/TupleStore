1 PICKED TASKS
 *0* for variable sized tuple, a tuple_size of 0 implies a max_size of tuple, to be returned
 *0* finalize tuple function is allowed to fail
 *0* max_size is specified to init_tuple and get_new_tuple function
 *0* fail inserting an element_def in a tuple_def, if the min_size exceeds the max_size
 *1* limit size_specifier_prefix_size to at most get_value_size_on_page(page_size), fail insertion of the element_def if this condition is violated.
 *2* store max_size of tuple with the tuple_def and fail updates if the tuple size is may cross the max_size limit

 *3* compact serializable form of tuple_def and tuple_def_summary, to be stored in WAL or passed over network, and functions to serialize and deserialize it.

 *4* Additionally implement a struct tuple_def_summary defined as struct {int is_variable_sized, uint32_t size_of_byte_offsets, union{uint32_t size, uint32_t min_size}}, easier to pass around in page_layout functions.

 *5* update_element_in_place to update element in place, if the element is fixed sized or has smaller than or equal value size to existing element

2 NEW TYPE TASKS
 *6* add long double (*think about it again, as long double does not have a ieee standardized format)
 *7* bit fields, having fixed number of bits (upto 64)
 *7* bitmap field
     * pack multiple adjacent bit fields and multiple bitmap fields together, or some way to do it, minimizing space usage
 *8* variable length signed and unsigned integer (like that of leveldb and sqlite) (see you GMP (GNU MP) can be used here)
 *8* variable length real numbers (see how GMP (GNU MP) can be used here)
 *9* nested_tuple datatype
 *9* arrays of types

3 OPTIMIZATION FOR COMPRESSION TASKS
 *10* make provisions to reset the unused bytes to 0s on the page while performing init_page, run_page_compaction. The reseting of bits should happen always on init_page and run_page_compaction. and should happen if a macro is defined.
