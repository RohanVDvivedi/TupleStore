TASKS PICKED

 * set and can_set function for setting an element inside the contaier

 * for variable element count string, blob and array
   * expand_container(const data_type_info* dti, void* data, uint32_t index, uint32_t slots) -> adds slots number of slots after the first index number of elements i.e. the new empty slots will be placed at index
   * insert_to_container(const data_type_info* dti, void* data, uint32_t index, const user_value new_containee) -> new_containee must be if type of the containee of the dti container type
   * insert_all_to_container(const data_type_info* dti, void* data, uint32_t index, const user_value data2, uint32_t index2, uint32_t slots); data1 and data2 must be of same data_type_info
   * discard_from_container(const data_type_info* dti, void* data, uint32_t index, uint32_t slots) -> discards slots number of slots after the first index number of slots i.e. from slot index
 * test all getter and setter fucntions

1 NEW TYPE TASKS
 *1*
   * get using user_value
   * set using user_value
   * print function for user_value
   * add hash_map for type_name based type casting, comparing and hashing

 *2*
 * refactor the project to work with data_type_info instead of the tuple_def -> data_type_info and tuple_size_def -> tuple_size_info
 * page_layouts will only work with tuples and believe that tuples are only being stored
 * every data_type_info (except bit_fieds) can be used to get us tuple_size_info, that can be further passed into page_layout functions
   * it will consist of following
   * type
   * is_variable_sized
   * Union of size and min_size
   * max_size -> only used if variable sized -> necessary to know about the size requirement of prefix size and prefix element count for container types
   * for arrays we have explicity containee information, and implicit for string and blob
     * is_nullable -> to know if we need a is_valid bit in prefix bitmap
     * is_bit_field
     * is_variable_sized -> never set of is_bit_field is set -> if this is set, the size can be read from prefix, else we have only the element count in the prefix
     * Union of size and bit_field_size
 * this much information is enough for the page_layout functions to determine the page_layout and the size of the tuple that is being inserted

 *3* compact serializable form of tuple_def -> data_type_info and tuple_size_def -> tuple_size_info, to be stored in WAL or passed over network, and functions to serialize and deserialize it, use Cutlery streams after it has been implemented/moved to Cutlery.

2 OPTIMIZATION FOR COMPRESSION TASKS
 *4* make provisions to reset the unused bytes to 0s on the page while performing init_page and run_page_compaction. The reseting of bits should happen always on init_page and run_page_compaction. and should happen if a macro is defined.
