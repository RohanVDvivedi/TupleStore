TASKS PICKED

   * define and declare static types, of all possible default types (especially for UINT_1_NON_NULLABLE as containee of the strings and blobs), and macros/functions to initialize sized fixed length strings, blobs, tuples and arrays * also add a function to get the required size of tuple data_type_info
   * test finalize function for various types, and dry run their prints


1 NEW TYPE TASKS
 *1*
   * function to get an element in the container, return the void* to the element
   * move_variable_sized_containee_to_end_of_container
     * implement logic to send a variable length element to the end of the tuple, use cutlery's left_rotate functionality
     * to move the variable length element to the end just perform memory_left_rotate(tuple + offset, tuple_size - offset, total size of variable length element_size)
     * we can do the same for making space for the appends and insert
     * add logic to add or substract all byte offsets by a specified value, if they are greater than a particular value
   * is_variable_sized_containee_at_end_of_container
   * set function to set an element in the container, returns updated size, and also takes in max size
   * can_set function to check if we can set the element inside the container, with allowable maximum expansion size
   * set NULL function to set a containee to NULL -> fails for a non_nullable element -> given by the function
   * initialize function to set a containee to all numeral types to 0s, STRING, BLOB to all 0s or empty (if variable sized), TUPLE with all elements to 0 values (if non nullable) or NULLS, for fixed length arrays to all 0s (if non nullable) or NULLs, and variable length arrays to 0 elements.
   * for variable element count string, blob and arrays
     * expand_element_count(data_type_info* dti, void* data, uint32_t i, uint32_t slots) -> adds slots number of slots after the first i elements i.e. the new empty slots will be from index i
     * discard_elements(data_type_info* dti, void* data, uint32_t i, uint32_t slots) -> discards slots number of slots after the first i slots i.e. from slot i
   * add a hashmap for the system where types can be added,
   * add their function pointers for compare and hash

 *2*
 * refactor the project to work with data_type_info instead of the tuple_def -> data_type_info and tuple_size_def -> tuple_size_info
 * page_layouts will only work with tuples and believe that tuples are only being stored
 * every data_type_info (except bit_fieds) can be used to get us tuple_size_info, that can be further passed into page_layout functions
   * it will consist of following
   * type
   * is_variable_sized
   * Union of size and min_size
   * max_size -> only used if variable sized -> necessary to know about the size requirement of prefix size and prefix element count for container types
   * for arrays we have explicity containee information, and implicit for string and blob
     * is_nullable -> to know if we need a is_valid bit in prefix bitmap
     * is_bit_field
     * is_variable_sized -> never set of is_bit_field is set -> if this is set, the size can be read from prefix, else we have only the element count in the prefix
     * Union of size and bit_field_size
 * this much information is enough for the page_layout functions to determine the page_layout and the size of the tuple that is being inserted

 *3* compact serializable form of tuple_def -> data_type_info and tuple_size_def -> tuple_size_info, to be stored in WAL or passed over network, and functions to serialize and deserialize it, use Cutlery streams after it has been implemented/moved to Cutlery.

2 OPTIMIZATION FOR COMPRESSION TASKS
 *4* make provisions to reset the unused bytes to 0s on the page while performing init_page and run_page_compaction. The reseting of bits should happen always on init_page and run_page_compaction. and should happen if a macro is defined.
