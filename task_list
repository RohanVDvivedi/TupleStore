
1 OPTIMIZATION FOR COMPRESSION TASKS
 * make provisions to reset the unused bytes to 0s on the page while performing init_page, run_page_compaction, deleting a tuple, or updating a tuple. The reseting of bits should happen always on init_page, run_page_compaction. and should happen if a macro is defined OR use a global variable for this.
 * compact serializable form of tuple_def, and ways to convert to and from it to its object form. This will be flushed to log records or sent to the user on the network if and when required.

2 FAR FAR FUTURE FEATURES
 * add long double
 * additional data types: variable length real numbers with variable base and nested_tuple datatype
 * varint like that of leveldb, boolean type to store 1 bit of information, multiple booleans can be packed on a single byte and also possess bit_offset along with byte_offset (like how other types have only byte_offset).
 * introduce enum types with bits lesser than or equal to 16, and these can be packed with booleans

3 TASKS FOR PROVIDING ATOMICITY AND DURABILITY
 * add logging
 * parser for log records, with log sequence numbers
 * undo functions to undo all (modifying) operations of page_layout in undo_page_layout.h

4 IN THIS REPO OR OTHER REPO
 * implement logger and an interface to log and update, all operations of page_layout.h
 * implement strict 2-pl lock manager, managing transaction structs and page_lock structs, transactions store transaction_id, a condition variable (to wait for acquiring lock on a page) and a list of pages that it already has lock on, and page_lock stores, transaction_id, that locked it, list of transactions waiting to read,write and upgrade (read to write) the lock.
 * lock manager also defines a struct that stores page_log_sequence_number and transaction_id that made the last change.
 * lock manager requests page from bufferpool.
