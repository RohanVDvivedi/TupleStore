TASKS PICKED
 
 * add function to zero out free space on the page
   * returns 1 only if there were any free space bytes on the page
   * very simple task for both slotted page and fixed array page
   * just call memory_set(page + get_offset_to_start_of_free_space, 0, get_offset_to_end_of_free_space - get_offset_to_start_of_free_space); for the corresponding page type

 * make hashers take these struct to hash
  struct byte_stream_hasher{
   uint64_t hash;
   uint64_t hash_func(uint64_t hash, uint8_t byte);
   }
   uint64_t hash_bytes(ts_hasher* tsh, uint8_t* bytes, uint32_t size);
   uint64_t hash_byte(ts_hasher* tsh, uint8_t byte);
   * use these in all the functions that demand hashing
   * implement a simple hash function based on this scheme like fnv 1a here (http://www.isthe.com/chongo/tech/comp/fnv/)
   * and a macro to create a local variable for such a hasher, that gets its pointer passed around and hash values returned
   like #define FNV_1A &(byte_stream_hasher){.hash = FNV_1A_CONSTANT, .hash_func = fnv_1a_byte_stream_hash_func}

1 NEW TYPE TASKS

 *1*
  * add hash_tables for type_name based type casting, comparing and hashing
    * also support getting min and max values for given types
    * as soon as you implement type based comparators for the tuple store, the suffix truncation in bplus tree will break so fix that soon after that