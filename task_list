
1 OPTIMIZATION FOR COMPRESSION TASKS
 * make provisions to reset the unused bytes to 0s on the page while performing init_page, run_page_compaction, deleting a tuple, or updating a tuple. The reseting of bits should happen always on init_page, run_page_compaction. and should happen if a macro is defined OR use a global variable for this.
 
1.1 NEW EASY TASKS
 * compact serializable form of tuple_def, and ways to convert to and from it to its object form. This will be flushed to log records or sent to the user on the network if and when required.
 * Additionally implement a struct tuple_def_summ a tuple definition summary for any tuple def. It will store a bit field stating whether it is a variable sized or fixed sized tuple_def and a union{ uint8_t size_of_byte_offsets (for varibale sized tuple) ; uint32_t tuple_size (for fixed sized tuples);}. Now we can refactor the page_layout* code to only work with tuple_def_summ, since tuple_def_summ is everything that page_layout* will need to work with. It does not need whole tuple_def. This will allows us to log (in WAL) the tuple_def_summ instead of a big tuple_def. We will also need serialization method for tuple_def_summ.
 * make sure to avoid all overflows, sizes are 32 bits, use 64 bit ints while multiplying them.
 * limit size_specifier_prefix_size to at most get_value_size_on_page(page_size), fail insertion of the element_def if this condition is violated.

2 FAR FAR FUTURE FEATURES
 * add long double
 * additional data types: variable length real numbers with variable base and nested_tuple datatype
 * varint like that of leveldb, boolean type to store 1 bit of information, multiple booleans can be packed on a single byte and also possess bit_offset along with byte_offset (like how other types have only byte_offset).
 * introduce enum types with bits lesser than or equal to 16, and these can be packed with booleans

3 TASKS FOR PROVIDING ATOMICITY AND DURABILITY
 * add logging
 * parser for log records, with log sequence numbers
 * undo functions to undo all (modifying) operations of page_layout in undo_page_layout.h

4 IN THIS REPO OR OTHER REPO
 * implement logger and an interface to log and update, all operations of page_layout.h
 * implement strict 2-pl lock manager, managing transaction structs and page_lock structs, transactions store transaction_id, a condition variable (to wait for acquiring lock on a page) and a list of pages that it already has lock on, and page_lock stores, transaction_id, that locked it, list of transactions waiting to read,write and upgrade (read to write) the lock.
 * lock manager also defines a struct that stores page_log_sequence_number and transaction_id that made the last change.
 * lock manager requests page from bufferpool.
