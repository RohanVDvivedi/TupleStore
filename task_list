1 NEW TYPE TASKS
 *1*
   * test finalize function for various types
   * define and declare static types, of all possible default types (especially for UINT_1_NON_NULLABLE as containee of the strings and blobs), and macros to initialize sized fixed length strings, blobs and arrays
   * get function to get an element in the container, return the void* to the element
   * move_variable_sized_containee_to_end_of_container
     * implement logic to send a variable length element to the end of the tuple, use cutlery's left_rotate functionality
     * to move the variable length element to the end just perform memory_left_rotate(tuple + offset, tuple_size - offset, total size of variable length element_size)
     * we can do the same for making space for the appends and insert
     * add logic to add or substract all byte offsets by a specified value, if they are greater than a particular value
   * set function to set an element in the container, returns updated size, and also takes in max size
   * can_set function to check if we can set the element inside the container, with allowable maximum expansion size
   * set NULL function to set a containee to NULL -> fails for a non_nullable element -> given by the function
   * initialize function to set a containee to all numeral types to 0s, STRING, BLOB to all 0s or empty (if variable sized), TUPLE with all elements to 0 values (if non nullable) or NULLS, for fixed length arrays to all 0s (if non nullable) or NULLs, and variable length arrays to 0 elements.
   * for variable element count string, blob and arrays
     * expand_element_count(data_type_info* dti, void* data, uint32_t i, uint32_t slots) -> adds slots number of slots after the first i elements i.e. the new empty slots will be from index i
     * discard_elements(data_type_info* dti, void* data, uint32_t i, uint32_t slots) -> discards slots number of slots after the first i slots i.e. from slot i
   * add a hashmap for the system where types can be added,
   * add their function pointers for compare and hash

*2* after this each tuple has a non-nullable bit, now for a fixed length tuple, if a non-nullable bit is set, then make a new page layout.
  * that does not have a bit map stored for the is_valid bits, and has neither tuple_count nor the tomb_stone_count
  * it will only have page_header and array of fixed length non-nullable tuples
  * you will not be allowed to append, insert, or discard tuples they all fail, their cn_append, can_insert and discard_all/discard trailing tomb_stones counterparts return 0
  * you can still get_nth_tuple, update_tuple and update_inplace_element, but can never update tuples to NULL
  * get_tuple_count will always return the max tuple count on the page
  * exists tuple on tha page, will return 1, if it is without bounds
  * implement space query functions accordingly
  * such a page can be used to build bitmap pages/indexes, and interior pages of page_table and array_table, bitmap pages for page allocation bitmaps

 *3* compact serializable form of tuple_def and tuple_def_summary, to be stored in WAL or passed over network, and functions to serialize and deserialize it, use Cutlery streams after it has been implemented/moved to Cutlery.

2 OPTIMIZATION FOR COMPRESSION TASKS
 *4* make provisions to reset the unused bytes to 0s on the page while performing init_page and run_page_compaction. The reseting of bits should happen always on init_page and run_page_compaction. and should happen if a macro is defined.
