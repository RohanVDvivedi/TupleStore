1* think how to do it (using a macro or a separate param to every function or just do it during compaction)
 * make provisions to reset the unused bytes to 0s on the page while performing init_page, run_page_compaction, deleting a tuple, updating a tuple and swaping the tuple. The reseting of bits should happen always on init_page, run_page_compaction. and should happen if a macro is defined on a swap, update or delete.
  * this will avail better compression on the page

2* implement it in a separate branch, since we need to test compatibility
 * provide an option to use is_NON_NULL_field, to save ourselves from allocating a bit in the bitmap for the fields that can not be NULL.
 * provide a bit_offset_to_is_null_bit_in_is_null_bitmap value attribute to element_def, since now each element's bit can be at a different location in the is_null_bitmap
 * non_null fields when written to by NULL are just set to 0

3* build read_ux, read_ix, write_ux, write_ix (ix requires sign extension) to read and write_x byte integer values, and write/read_float/double - read/write only as little endian
 * use them to read_value_from_page and write_value_from_page, allow 3 byte values on page and in tuple offsets
 * refactor element from a union of pointers to just a void* just like the representation of a tuple
 * provide int, unsigned int types the sizes all the way from 1 to 8 bytes wide
 * perform comparisions for unsigned int and int by reading them as uint64 and int64 before comparing
 * segregate string/blob compare/assign/hash functions to a different different classes, real compare assign functions to their classes, int/uint compare assign functions to their separate classes
Build this on similar lines of, also implement u32 and i32 fundtions
uint64_t read_u64(const void* data, uint32_t size)
{
    if(size > 8)
        return -1;
    const uint8_t* data8 = data;
    uint64_t res = 0;
    for(uint32_t i = 0; i < size; i++)
        res = (res << 8) | data8[i];
    return res;
}

void write_u64(void* data, uint32_t size, uint64_t x)
{
    if(size > 8)
        return;
    uint8_t* data8 = data;
    for(uint32_t i = 0; i < size; i++)
    {
        data8[size-1-i] = (x & 0xff);
        x = x >> 8;
    }
}

int64_t read_i64(const void* data, uint32_t size)
{
    if(size > 8)
        return -1;
    const uint8_t* data8 = data;
    int64_t res = 0;
    if(data8[0] & 0x80)
        res = -1;
    for(uint32_t i = 0; i < size; i++)
        res = (res << 8) | data8[i];
    return res;
}

void write_i64(void* data, uint32_t size, int64_t x)
{
    if(size > 8)
        return;
    uint8_t* data8 = data;
    for(uint32_t i = 0; i < size; i++)
    {
        data8[size-1-i] = (x & 0xff);
        x = x >> 8;
    }
}
