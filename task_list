TASKS PICKED

 * default compare and hash functions for user_value
 * convert data and data_size to blob_value and blob_size in user value struct
 * nested get, set, hash, compare, expand, and discard functions with positional_accessor, taking in tuple_def and tuple as input using positional accessor
 * redefine struct tuple_def {
    tuple_size_def size_def;    // only thing required by page_layout
    data_type_info* type_info;  // can be any type_info except a BIT_FIELD type
 }
 * creation of every tuple_def finalizes its type_info, initializes its size_def
 * tuple_size_def has 2 major fiunctions get_size and is_variable_sized
 * redefine struct tuple_size_def {
    is_variable_sized:1;

    union{size, min_size}; -> use size directly, if is_variable_sized = 0 

    // below two fields are used only when is_variable_size = 1
    has_size_in_prefix:1; // -> if set directly read size from the prefix
    has_element_count_in_pefix:1; // -> need to do more work

    max_size; // to read size OR element_count from prefix using read_value_from_page(, max_size)

    // are only required when has_size_in_prefix = 0, and has_element_count_in_pefix = 1, this configuration implies is_variable_size = 0
    // this also implies that the element_count is variable, but the individual element is fixed size (may or may not be nullable)
    // this is the case with variable size string, variable sized blob, and variable element count fixed sized element arrays
    does_containee_need_is_valid_bit_in_prefix:1;
    int is_containee_bit_field:1; // -> can either be a bitfield or not
    union {containee_size, containee_bit_field_size}; // -> if bitfield gives bit field size, else the actual size of fixed sized containee
 } // if packed this struct is no more than 1 + 32 + 1 + 1 + 32 + 1 + 1 + 32 = 101 bits = 13 bytes

1 NEW TYPE TASKS

 *1*
 * add hash_tables for type_name based type casting, comparing and hashing
 * only tuples can be stored on the disk, and each tuple has a corresponding tuple_def, and each tuple_def contains a tuple_size_def

 *2* compact serializable form of tuple_def and tuple_size_def, to be stored in WAL or passed over network, and functions to serialize and deserialize it, use Cutlery streams after it has been implemented/moved to Cutlery.

2 OPTIMIZATION FOR COMPRESSION TASKS
 *3* make provisions to reset the unused bytes to 0s on the page while performing init_page and run_page_compaction. The reseting of bits should happen always on init_page and run_page_compaction. and should happen if a macro is defined.
