TASKS PICKED

 * modify getter function to get offset
 * make a new getter function that returns user value
 * user value to also accomodate tuple and array types
 * repurpose numeral type elements and string and blob type elements code

 * set function to set an element in the container, returns updated size, and also takes in max size increment that it can suffer
 * can_set function to check if we can set the element inside the container, with allowable maximum expansion size
 * set NULL function to set a containee to NULL -> fails for a non_nullable element -> given by the function
 * for variable element count string, blob and arrays
   * expand_element_count(data_type_info* dti, void* data, uint32_t i, uint32_t slots) -> adds slots number of slots after the first i elements i.e. the new empty slots will be from index i
   * discard_elements(data_type_info* dti, void* data, uint32_t i, uint32_t slots) -> discards slots number of slots after the first i slots i.e. from slot i
 * test all getter ans setter fucntions

1 NEW TYPE TASKS
 *1*
   * add a hashmap for the system where types can be added,
   * add their function pointers for compare and hash

 *2*
 * refactor the project to work with data_type_info instead of the tuple_def -> data_type_info and tuple_size_def -> tuple_size_info
 * page_layouts will only work with tuples and believe that tuples are only being stored
 * every data_type_info (except bit_fieds) can be used to get us tuple_size_info, that can be further passed into page_layout functions
   * it will consist of following
   * type
   * is_variable_sized
   * Union of size and min_size
   * max_size -> only used if variable sized -> necessary to know about the size requirement of prefix size and prefix element count for container types
   * for arrays we have explicity containee information, and implicit for string and blob
     * is_nullable -> to know if we need a is_valid bit in prefix bitmap
     * is_bit_field
     * is_variable_sized -> never set of is_bit_field is set -> if this is set, the size can be read from prefix, else we have only the element count in the prefix
     * Union of size and bit_field_size
 * this much information is enough for the page_layout functions to determine the page_layout and the size of the tuple that is being inserted

 *3* compact serializable form of tuple_def -> data_type_info and tuple_size_def -> tuple_size_info, to be stored in WAL or passed over network, and functions to serialize and deserialize it, use Cutlery streams after it has been implemented/moved to Cutlery.

2 OPTIMIZATION FOR COMPRESSION TASKS
 *4* make provisions to reset the unused bytes to 0s on the page while performing init_page and run_page_compaction. The reseting of bits should happen always on init_page and run_page_compaction. and should happen if a macro is defined.
