
1 MISCELLANEOUS
 * make sure to avoid all 32 bit overflows, using cutlery will_unsigned_sum_overflow and will_unsigned_mul_overflow functions.

2 OPTIMIZATION FOR COMPRESSION TASKS
 * make provisions to reset the unused bytes to 0s on the page while performing init_page, run_page_compaction, deleting a tuple, or updating a tuple. The reseting of bits should happen always on init_page, run_page_compaction. and should happen if a macro is defined OR use a global variable for this.
 
3 TUPLE_DEF TASKS
 * compact serializable form of tuple_def, and ways to convert to and from it to its object form. This will be flushed to log records or sent to the user on the network if and when required.
 * Additionally implement a struct tuple_def_summary a tuple definition summary for any tuple def. It will store a bit field stating whether it is a variable sized or fixed sized tuple_def and a union{ uint8_t size_of_byte_offsets (for varibale sized tuple) ; uint32_t tuple_size (for fixed sized tuples);}. Now we can refactor the page_layout* code to only work with tuple_def_summ, since tuple_def_summ is everything that page_layout* will need to work with. It does not need whole tuple_def. This will allows us to log (in WAL) the tuple_def_summ instead of a big tuple_def. We will also need serialization method for tuple_def_summ.
 * limit size_specifier_prefix_size to at most get_value_size_on_page(page_size), fail insertion of the element_def if this condition is violated.

4 PAGE_LAYOUT TASKS
 * rename insert_tuple to append_tuple
 * remove discarding trailing tombstones from delete and swap functions
 * add discarding trailing tombstone functionality to the run_page_compaction
 * append_tuple when passed with a NULL tuple appends a tombstone
 * update_tuple when passed with a NULL tuple deletes a tuple, remove delete function altogether
 * update_element_in_place to update element in place, if the element is fixed sized or has smaller than or equal value size to existing element

5 NEW TYPE TASKS
 * add long double
 * variable length signed and unsigned integer (like that of leveldb and sqlite)
 * variable length real numbers
 * nested_tuple datatype
 * bit fields, having variable number of bits (upto 64), pack multiple adjacent bit fields together
