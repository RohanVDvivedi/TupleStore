
1 MISCELLANEOUS
 *1* make sure to avoid all 32 bit overflows, using cutlery will_unsigned_sum_overflow and will_unsigned_mul_overflow functions.

4 PAGE_LAYOUT TASKS
 *2* rename all page_layout functions to have _on_page as suffix, this will avoid collision with any other future library
 *2* remove `discarding trailing tombstones` feature from delete and swap functions
 *2* add discarding trailing tombstone as a separate functionality, make this function return the discarded tombstones count
 *2* remove `discard tombstones functionality` from the run_page_compaction
 *2* make the run_page_compaction function return bytes suggesting the new free space
 *2* append_tuple when passed with a NULL tuple appends a tombstone
 *2* update_tuple when passed with a NULL tuple deletes a tuple, remove delete function altogether
 *2* update_element_in_place to update element in place, if the element is fixed sized or has smaller than or equal value size to existing element
 *2* in run page compaction use value arraylist for sorting the slots by the tuple pointer it points to
 *2* implement can_update_tuple function, to make a prior check for update call

3 TUPLE_DEF TASKS
 *4* Additionally implement a struct tuple_def_summary defined as struct {int is_variable_sized, uint32_t size}, easier to pass around in page_layout functions.
 *4* compact serializable form of tuple_def and tuple_def_summary, to be stored in WAL or passed over network, and functions to serialize and deserialize it.
 *4* limit size_specifier_prefix_size to at most get_value_size_on_page(page_size), fail insertion of the element_def if this condition is violated.
 *4* use value arraylist for list of element defs in the tuple_def

5 NEW TYPE TASKS
 *5* add long double (*think about it again, as long double does not have a ieee standardized format)
 *6* bit fields, having fixed number of bits (upto 64)
 *6* bitmap field
     * pack multiple adjacent bit fields and multiple bitmap fields together, or some way to do it, minimizing space usage
 *7* variable length signed and unsigned integer (like that of leveldb and sqlite) (see you GMP (GNU MP) can be used here)
 *7* variable length real numbers (see how GMP (GNU MP) can be used here)
 *8* nested_tuple datatype
 *8* arrays of types

2 OPTIMIZATION FOR COMPRESSION TASKS
 *9* make provisions to reset the unused bytes to 0s on the page while performing init_page, run_page_compaction, deleting a tuple, or updating a tuple. The reseting of bits should happen always on init_page, run_page_compaction. and should happen if a macro is defined OR use a global variable for this.
